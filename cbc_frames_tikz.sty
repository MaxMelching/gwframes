%% start of file `cbc_frames_tikz.sty'.
%% Copyright 2024 Max Melching (m-melching@web.de).
%
% This work may be distributed and/or modified under the
% conditions of the LaTeX Project Public License version 1.3c,
% available at http://www.latex-project.org/lppl/.


\ProvidesPackage{cbc_frames_tikz}

\RequirePackage{tikz}
\RequirePackage{tikz-3dplot}
\RequirePackage{xcolor}
\RequirePackage{wasysym}  % For \ascnode symbol

\RequirePackage{earth_tikz}


\usetikzlibrary{
	arrows.meta,
	math,
	calc,
    3d,
    backgrounds,
}


\tikzset{
    >={Stealth[inset=0,angle'=27]},
    % -- Define custom layers keyword. Credit: https://tex.stackexchange.com/questions/20425/z-level-in-tikz
    layer/.style={%
        execute at begin scope={\pgfonlayer{#1}},
        execute at end scope={\endpgfonlayer}
    },
    coordinate axis/.style={
        ->,
        black,
        semithick,
        layer=axes,
    },
    angle/.style={
        fill,
        opacity=0.42,
        layer=angles,
    },
    helper lines/.style={
        thick,
        gray!70!black,
        dotted,
        opacity=0.5,
        layer=BackGround,
    },
}


\definecolor{persianblue}{rgb}{0.11, 0.22, 0.73}
\definecolor{burntorange}{rgb}{0.8, 0.33, 0.0}
\definecolor{brown(traditional)}{rgb}{0.59, 0.29, 0.0}
\definecolor{carolinablue}{rgb}{0.6, 0.73, 0.89}
\definecolor{amethyst}{rgb}{0.6, 0.4, 0.8}


\definecolor{racolor}{named}{brown(traditional)}
\definecolor{deccolor}{named}{teal}
\definecolor{distancecolor}{named}{purple}
\definecolor{polcolor}{named}{burntorange}
\definecolor{phirefcolor}{named}{carolinablue}
\definecolor{longasccolor}{named}{persianblue}
\definecolor{inccolor}{named}{amethyst}


\tdplotsetmaincoords{70}{120} % So that a default is set


% -- Define default labels via commands, avoiding errors when setting
% -- pgfkeys with expressions that have to expanded (e.g. contain curly
% -- brackets or an "=")
\def\Inclination@Label{$\iota$}
\def\Ra@Label{$\alpha$}
\def\Dec@Label{$\delta$}
\def\Polarization@Label{$\psi$}
\def\Distance@Label{$D_L$}
\def\LineOfSightLabel{$\vec{N}$}
\def\PhiRef@Label{$\phi_\mathrm{ref}$}
\def\AscNode@Label{$\ascnode$}
% \def\Omega@Label{$\Omega = \pi/2 + \mathrm{longAscNodes}$}  % Error from the curly brackets...
\def\Omega@Label{$\Omega$}
\def\AzimuthalProjectionLabel{$\pi/2 -$\PhiRef@Label}


\pgfkeys{
	/frames/.is family, /frames,
	default/.style = {
        binary = {%
            mass1 = 20,
            mass2 = 10,
            eccentricity = 0,
            scalefactor = 1,
            % distance = 3,
        },
        distance = {%
            value = 3,
            show = true,
        },
        inclination = 0,
        polarization = 0,
        longascnodes = 0,
        phiref = 0,
        ra = 0,
        dec = 0,
        % -- No need to give defaults for labels, are all set above
        axislen = 3,
        axislabelpad = 0.12,  % Corresponds to 12% of \AxisLen
        uselayers = false,
        lineofsight/show = true,
        sourceframe = {%
            show = true,
            axes = true,
            helperlines = true,
        },
        signalframe = {%
            show = true,
            axes = true,
            helperlines = true,
            angles = true,
            ascnode = true,
            azimuthalangle = false,
        },
        celestialframe = {%
            show = true,
            angles = true,
            axes = true,
            helperlines = true,
        },
        earth = {%
            radius = 1.25,
            tilt = 0,
        },
        ifo = {%
            show = true,
            armlength = 2,
        },
    },
    % -- General note: For certain arguments, it makes sense to give them separately,
    % -- in addition to them being part of a subfamily. Thus, do not be surprised if
    % -- some things are defined multiple times.
    % 
    % -- Some general arguments
    axislen/.estore in = \AxisLen,
    axislabelpad/.estore in = \AxisLabelPad,
    uselayers/.estore in = \UseLayers,
    % 
    binary/mass1/.estore in = \massone,
    binary/mass2/.estore in = \masstwo,
    binary/eccentricity/.estore in = \eccentricity,
    eccentricity/.estore in = \eccentricity,
    binary/scalefactor/.estore in = \Binary@scalefactor,
    binary/distance/.estore in = \Binary@distance,
    binary/bhsizepersolmass/.estore in = \BHsizepersolmass,
    % 
    inclination/value/.estore in = \Inclination,
    inclination/show/.estore in = \Inclination@Show,
    inclination/label/.estore in = \Inclination@Label,
    % 
    polarization/value/.estore in = \Polarization,
    polarization/show/.estore in = \Polarization@Show,
    polarization/label/.estore in = \Polarization@Label,
    % 
    longascnodes/value/.code = {
        \def\LongAscNodes{#1}
        \def\LongAscOmega{#1 + 90}
    },
    longascnodes/show/.estore in = \LongAscNodes@Show,
    omegalabel/.estore in = \Omega@Label,
    % 
    phiref/value/.estore in = \PhiRef,
    phiref/show/.estore in = \PhiRef@Show,
    phiref/label/.estore in = \PhiRef@Label,
    % 
    ra/value/.estore in = \Ra,
    ra/show/.estore in = \Ra@Show,
    ra/label/.estore in = \Ra@Label,
    % 
    dec/value/.estore in = \Dec,
    dec/show/.estore in = \Dec@Show,
    dec/label/.estore in = \Dec@Label,
    % 
    lineofsight/show/.estore in = \LineOfSight@Show,
    lineofsight/label/.estore in = \LineOfSightLabel,
    % 
    distance/value/.estore in = \Binary@distance,
    distance/show/.estore in = \Binary@distance@show,
    distance/label/.estore in = \Distance@Label,
    % 
    ascnode/show/.estore in = \SignalFrame@AscNode@Show,
    ascnode/label/.estore in = \AscNode@Label,
    % 
    labels/inclination/.estore in = \Inclination@Label,
    labels/polarization/.estore in = \Polarization@Label,
    labels/longascnodes/.estore in = \LongAscNodes@Label,
    labels/omega/.estore in = \Omega@Label,
    labels/phiref/.estore in = \PhiRef@Label,
    labels/ra/.estore in = \Ra@Label,
    labels/dec/.estore in = \Dec@Label,
    labels/lineofsight/.estore in = \LineOfSight@Label,
    labels/distance/.estore in = \Distance@Label,
    labels/ascnode/.estore in = \AscNode@Label,
    % 
    angles/inclination/.code = {\passonpgfkeys{/frames}{inclination}{value}{#1}},
    angles/polarization/.code = {\passonpgfkeys{/frames}{polarization}{value}{#1}},
    angles/longascnodes/.code = {\passonpgfkeys{/frames}{longascnodes}{value}{#1}},
    angles/phiref/.code = {\passonpgfkeys{/frames}{phiref}{value}{#1}},
    angles/ra/.code = {\passonpgfkeys{/frames}{ra}{value}{#1}},
    angles/dec/.code = {\passonpgfkeys{/frames}{dec}{value}{#1}},
    % 
    sourceframe/show/.estore in = \ShowSourceFrame,
    sourceframe/axes/.estore in = \SourceFrameAxes,
    sourceframe/helperlines/.estore in = \SourceFrameHelperlines,
    % 
    signalframe/show/.estore in = \ShowSignalFrame,
    signalframe/axes/.estore in = \SignalFrameAxes,
    signalframe/helperlines/.estore in = \SignalFrameHelperlines,
    signalframe/angles/.estore in = \SignalFrameAngles,
    signalframe/ascnode/.estore in = \SignalFrame@AscNode@Show,
    signalframe/azimuthalangle/.estore in = \AzimuthalAngle,
    azimuthalangle/.estore in = \AzimuthalAngle,
    % 
    celestialframe/show/.estore in = \ShowCelestialFrame,
    celestialframe/axes/.estore in = \CelestialFrameAxes,
    celestialframe/helperlines/.estore in = \CelestialFrameHelperlines,
    celestialframe/angles/.estore in = \CelestialFrameAngles,
    % 
    ifo/show/.estore in = \IFO@Show,
    ifo/armlength/.estore in = \IFO@Armlength,
}


\def\BHsizepersolmass{1/20*0.7 cm} % So that 20 solmass BH has size of 0.7 cm


% -- Define a pgfkeys handler
% -- Arg 1: base family; arg 2: subfamily that we wish to parse
\newcommand*\pgfkeysdefvalueorkeys[3]{%
  \pgfkeys{#1/#2/.code={%
    \pgfutil@in@={##1}%
    \ifpgfutil@in@%
      % -- Multiple key-value pairs given, parse them
      \pgfkeysalso{#1/#2/.cd, ##1, #1/.cd}%
    \else
      % -- Only one value given, set it to "value" subkey
    \pgfkeysalso{#1/#2/#3=##1, #1/.cd}%  We NEED this because we want to trigger the setter, in order for commands to get defined
    \fi
  }}
  % -- It is CRUCIAL to navigate back to the base family, otherwise subsequent keys are not processed correctly
}

\newcommand*\passonpgfkeys[4]{%
    \pgfutil@in@={#4}%
    \ifpgfutil@in@%
        % -- Multiple key-value pairs given, parse them
        \pgfkeysalso{#1/#2/.cd, #4, #1/.cd}%
    \else
        % -- Only one value given, set it to "value" subkey
        \pgfkeysalso{#1/#2/#3=#4, #1/.cd}%  We NEED this because we want to trigger the setter, in order for commands to get defined
    \fi
}


\pgfkeysdefvalueorkeys{/frames}{inclination}{value}
\pgfkeysdefvalueorkeys{/frames}{polarization}{value}
\pgfkeysdefvalueorkeys{/frames}{longascnodes}{value}
\pgfkeysdefvalueorkeys{/frames}{phiref}{value}
\pgfkeysdefvalueorkeys{/frames}{ra}{value}
\pgfkeysdefvalueorkeys{/frames}{dec}{value}

\pgfkeysdefvalueorkeys{/frames}{lineofsight}{show}
\pgfkeysdefvalueorkeys{/frames}{distance}{value}
\pgfkeysdefvalueorkeys{/frames}{ascnode}{show}
\pgfkeysdefvalueorkeys{/frames}{labels}{}  % There is no sensible default here
\pgfkeysdefvalueorkeys{/frames}{angles}{}  % There is no sensible default here

\pgfkeysdefvalueorkeys{/frames}{binary}{show}
\pgfkeysdefvalueorkeys{/frames}{sourceframe}{show}
\pgfkeysdefvalueorkeys{/frames}{signalframe}{show}
\pgfkeysdefvalueorkeys{/frames}{celestialframe}{show}
\pgfkeysdefvalueorkeys{/frames}{earth}{radius}
% -- Earth already exists, due to earth_tikz file. But it is still important to define
% -- it here, so that we get correct navigation back (and convenient, too, for default)
\pgfkeysdefvalueorkeys{/frames}{ifo}{show}


\pgfkeys{/frames, default}  % Probably not required, but I want to make absolutely sure everything is defined



% -- NOTE: reason that rotation has no effect sometimes is due to named coordinates
% -- being used I think! So rotating something like "(earthpos) -- (binaryposition)"
% -- has no effect, we have to give coordinates like "(earthpos) -- ++(1, 0, 0)"


% -- NOTE: in order to understand how and why this file works, knowing about
% -- the following behaviour is crucial:
% -- * rotating in two separate environments is same as doing it in the same
% --   order in a single environment
% -- * order in which rotations are applied is from top to bottom
% -- * when in a rotated coordinate system, "rotate about x" refers to an
% --   operation in the rotated system, and not the initial, unrotated one



% TODO: implement show checks for all angles
\newcommand{\drawframes}[1][]{%
    % -- Import keys for styling
    \def\earthcalledfrombinary{true}
    \pgfkeys{/frames, default, #1}


    % -- Define image layers
    \pgfdeclarelayer{angles}
    \pgfdeclarelayer{axes}
    \pgfdeclarelayer{binary}
    \pgfdeclarelayer{BackGround}
    \pgfdeclarelayer{ForeGround}
    \pgfsetlayers{BackGround,angles,main,axes,ForeGround} % Order from back to front

    % -- Check whether layers shall be used
    \ifthenelse{\equal{\UseLayers}{false}}{
        \tikzset{layer/.style={}}
    }{}


    \ifthenelse{\equal{\ShowCelestialFrame}{true}}{
        % -- Draw earth
        \coordinate (earthpos) at (0, 0, 0);
        
        \begin{scope}[
            tdplot_screen_coords,
            shift={(earthpos)}, % To be future proof, does nothing right now
            layer=BackGround,
        ]
            \drawearth;
            
            % -- Draw interferometer on earth
            \ifthenelse{\equal{\IFO@Show}{true}}{
                \begin{scope}[
                    tdplot_screen_coords,
                    shift={(-0.12, 0.55)},
                    rotate=305+\angE,
                    scale=0.1*\RE,
                ]
                    \usetikzlibrary{decorations.markings, calc, arrows.meta, positioning, shadings}
                    
                    \tikzset{arrow inside/.style = {postaction=decorate, decoration={markings, mark=at position .67 with \arrow{stealth}}}}
                    
                    % \tikzset{laser/.style={black, fill=black!40}}
                    \tikzset{laser/.style={line width=0pt, black, outer color=black!40, inner color=black!32}}
                    \tikzset{ray/.style={thick, red}}%, arrow inside}} % Inner and outer color does not work
                    \tikzset{mirror/.style={line width=0pt, outer color=black!50, inner color=white}}
                    \tikzset{photodiode/.style={line width=0pt, outer color=orange!90!black, inner color=orange!40}}
                    
                    
                    \coordinate (BS) at (0, 0);
                    \coordinate (MX) at ($(BS) + (\IFO@Armlength, 0)$);
                    \coordinate (MY) at ($(BS) + (0, \IFO@Armlength)$);
                    \coordinate (LA) at ($(BS) - (0.3*\IFO@Armlength, 0)$);
                    \coordinate (PD) at ($(BS) - (0, 0.3*\IFO@Armlength)$);
                
                
                    \draw[ray] (LA) -- (BS) {}; % Laser -> beam splitter
                    \draw[ray] (BS) -- (MX) {}; % Beam splitter -> right mirror
                    \draw[ray] (BS) -- (MY) {}; % Beam splitter -> upper mirror
                    \draw[ray] (BS) -- (PD) {}; % Beam splitter -> photo diode
                
                    \draw[laser, shift={(LA)}] (0, -0.15) rectangle (-0.7, 0.15) {};
                    \draw[mirror, shift={(MX)}] (0, -0.3) rectangle (-0.2, 0.3) {};
                    \draw[mirror, shift={(MY)}] (-0.3, 0) rectangle (0.3, -0.2) {};
                    \draw[photodiode, shift={(PD)}] (0.3, 0) -- (-0.3, 0) arc[start angle=-180, end angle=0, radius=0.3cm-0.1pt] {};
                \end{scope}
            }{}
        \end{scope}

        
        \begin{scope}[
            tdplot_main_coords, % Make sure their default value is used
        ]
            % -- Celestial frame axes definition + drawing
            \coordinate (xdoubleprimetip) at (\AxisLen, 0, 0);
            \coordinate (ydoubleprimetip) at (0, \AxisLen, 0);
            \coordinate (zdoubleprimetip) at (0, 0, \AxisLen);

            \draw[coordinate axis] (earthpos) -- ++(xdoubleprimetip) node[pos=1+\AxisLabelPad]{$x''$};

            \draw[coordinate axis] (earthpos) -- ++(ydoubleprimetip) node[pos=1+\AxisLabelPad]{$y''$};

            \draw[coordinate axis] (earthpos) -- ++(zdoubleprimetip) node[pos=1+\AxisLabelPad]{$z''$};


            \ifthenelse{\equal{\CelestialFrameAngles}{true}}{
                % -- Visualization of dec
                \ifnum\Dec=0
                \else
                    \begin{scope}[
                        rotate around z=\Ra,
                        rotate around x=-90,
                        deccolor,
                    ]
                        \draw[angle] (earthpos) -- (\AxisLen, 0, 0) arc (0:-\Dec:\AxisLen);
                        
                        \draw[
                            layer=angles,
                            ->,
                            thick,
                        ] (earthpos) ++(\AxisLen, 0, 0) arc (0:-\Dec:\AxisLen);
                        
                        \draw[
                            layer=angles,
                            draw=none,
                        ] (earthpos) ++({(1+\AxisLabelPad)*\AxisLen}, 0, 0) arc (0:-\Dec:{(1+\AxisLabelPad)*\AxisLen}) node[midway] {\Dec@Label};
                    \end{scope}
                \fi
            
            
                % -- Visualization of ra
                \ifnum\Ra=0
                \else
                    \begin{scope}[
                        racolor,
                    ]
                        \draw[angle] (earthpos) -- (\AxisLen, 0, 0) arc (0:\Ra:\AxisLen);
                        
                        \draw[
                            layer=angles,
                            ->,
                            thick,
                        ] (earthpos) ++(\AxisLen, 0, 0) arc (0:\Ra:\AxisLen);
                        
                        \draw[
                            layer=angles,
                            draw=none,
                        ] (earthpos) ++({(1+\AxisLabelPad)*\AxisLen}, 0, 0) arc (0:\Ra:{(1+\AxisLabelPad)*\AxisLen}) node[midway] {\Ra@Label};
                    \end{scope}
                \fi
            }{}

        \end{scope}

    }{} % End of DrawCelestialFrame if clause


    % -- Rotations to go into signal frame
    \begin{scope}[
        tdplot_main_coords,
        rotate around z=\Ra,
        rotate around y=-\Dec, % Fine for position, no direction/orientation involved
    ]
        \coordinate (binaryposition) at (\Binary@distance*\AxisLen, 0, 0);
    \end{scope}


    % -- Shift to really go into signal frame, in addition to rotation
    \ifthenelse{\equal{\ShowCelestialFrame}{true}}{
        % -- Apply rotations
        \begin{scope}[
            tdplot_main_coords,
            shift={(binaryposition)},
            rotate around z=-90+\Ra,
            rotate around x=90+\Dec,
        ]

        \begin{scope}[
            % rotate around z=-\Polarization, % Clockwise about z'
            rotate around z=\Polarization, % Counter-clockwise about z'
        ]
    }{
        % -- No rotations required
        \begin{scope}[
            tdplot_main_coords,
            shift={(binaryposition)},
        ]    
    }
        % -- Signal frame axes definition + drawing
        \coordinate (xprimetip) at (\AxisLen, 0, 0);
        \coordinate (yprimetip) at (0, \AxisLen, 0);
        \coordinate (zprimetip) at (0, 0, \AxisLen);

        \ifthenelse{\equal{\SignalFrameAxes}{true}}{
            \draw[coordinate axis] (binaryposition) -- (xprimetip) node[pos=1+\AxisLabelPad]{$x'$};

            \draw[coordinate axis] (binaryposition) -- (yprimetip) node[pos=1+\AxisLabelPad]{$y'$};

            \draw[coordinate axis] (binaryposition) -- (zprimetip) node[pos=1+\AxisLabelPad]{$z'$};
        }{}

        
        % -- Helper lines
        \ifthenelse{\equal{\SignalFrameHelperlines}{true}}{
            \begin{scope}[
                canvas is xy plane at z=0,
            ]
                \draw[helper lines] (0.0, 0.0, 0.0) circle(\AxisLen cm) {};
            \end{scope}
        }{}


        % -- Rotations to go into source frame
        \begin{scope}[
            % rotate around z=-\LongAscOmega,
            rotate around z=\LongAscOmega,
        ]
            \begin{scope}[
                rotate around x=\Inclination,
                rotate around z=\PhiRef,
            ]
     
                \begin{scope}[
                    canvas is xy plane at z=0, % Needed for rotation of circle to work properly
                ]
                    \coordinate (bhoneposition) at (0.5*\Binary@scalefactor*\AxisLen, 0, 0);
                    \coordinate (bhtwoposition) at (-0.5*\Binary@scalefactor*\AxisLen, 0, 0);

                    % -- Following may be overly complicated, but it works
                    \coordinate (bhonepositionresc) at ($ {\masstwo/(\massone+\masstwo)}*(bhoneposition) $);
                    \coordinate (bhtwopositionresc) at ($ {\massone/(\massone+\masstwo)}*(bhtwoposition) $);
                    \coordinate (com) at ($ (bhonepositionresc) + (bhtwopositionresc) $);

                    \coordinate (bhonepositioncom) at ($ 2*(bhonepositionresc) $);
                    \coordinate (bhtwopositioncom) at ($ 2*(bhtwopositionresc) $);
                    % -- 2 only works because we want distance between them.
                    % -- Since axislen is already in x-component, we only have
                    % -- to multiply with 2 to get distance between them
                    % -- -> see https://en.wikipedia.org/wiki/Barycenter_(astronomy)#Two-body_problem

                    
                    \draw[
                        gray,
                        dashed,
                        thick,
                        opacity=0.5,
                        yscale=1-\eccentricity,
                    ] (com) circle(0.5*\Binary@scalefactor*\AxisLen cm) {};
                    
                    \node[
                        fill,
                        circle,
                        minimum size={\massone*\BHsizepersolmass},
                        inner sep=0pt,
                    % ] at (com)++(bhonepositioncom) {};
                    ] at (bhonepositioncom) {};
                    
                    \node[
                        fill,
                        circle,
                        minimum size={\masstwo*\BHsizepersolmass},
                        inner sep=0pt,
                    % ] at (bhtwoposition) {};
                    ] at (bhtwopositioncom) {};
                \end{scope}
    
    
                % -- Source frame axes definition + drawing
                \coordinate (xtip) at (\AxisLen, 0, 0);
                \coordinate (ytip) at (0, \AxisLen, 0);
                \coordinate (ztip) at (0, 0, \AxisLen);

                \ifthenelse{\equal{\SourceFrameAxes}{true}}{
                    \draw[coordinate axis] (binaryposition) -- (xtip) node[pos=1+\AxisLabelPad]{$x$};

                    \draw[coordinate axis] (binaryposition) -- (ytip) node[pos=1+\AxisLabelPad]{$y$};

                    \draw[coordinate axis] (binaryposition) -- (ztip) node[pos=1+\AxisLabelPad]{$z$};
                }{}
        

                \ifthenelse{\equal{\SignalFrameAngles}{true}}{
                    % -- Visualization of inclination
                    \ifnum\Inclination=0
                    \else
                        \begin{scope}[
                            rotate around z=-\PhiRef,
                            rotate around x=-\Inclination,
                            rotate around y=-90,
                            inccolor,
                        ]
                            \draw[angle] (binaryposition) -- (zprimetip) arc (0:-\Inclination:\AxisLen);
                            
                            \draw[
                                layer=angles,
                                ->,
                                thick,
                            ] (zprimetip) arc (0:-\Inclination:\AxisLen);

                            \draw[
                                layer=angles,
                                draw=none,
                            ] (${(1+\AxisLabelPad)}*(zprimetip)$) arc (0:-\Inclination:{(1+\AxisLabelPad)*\AxisLen}) node[midway] {\Inclination@Label};
                        \end{scope}
                    \fi
        
        
                    % -- Visualization of PhiRef
                    \ifnum\PhiRef=0
                    \else
                        \draw[angle, phirefcolor] (binaryposition) -- (xtip) arc (0:-\PhiRef:\AxisLen);
                        
                        \draw[
                            layer=angles,
                            <-,
                            thick,
                            phirefcolor,
                        ] (binaryposition) ++(xtip) arc (0:-\PhiRef:\AxisLen);

                        \draw[
                            layer=angles,
                            draw=none,
                            phirefcolor,
                        ] (binaryposition) ++(${(1+\AxisLabelPad)}*(xtip)$) arc (0:-\PhiRef:{(1+\AxisLabelPad)*\AxisLen}) node[midway] {\PhiRef@Label};
                    \fi

                    \ifthenelse{\equal{\AzimuthalAngle}{true}}{
                        % -- Visualize phiN from Fig. 1 of https://www.nature.com/articles/s41550-025-02632-5
                        \begin{scope}[
                            layer=angles,
                            rotate around z=90-\PhiRef,
                        ]
                            \begin{scope}[
                                rotate around x=90,
                            ]
                                \draw[
                                    distancecolor,
                                    thick,
                                    dashed,
                                ] (binaryposition) --++ (\AxisLen, 0, 0) arc (0:90-\Inclination:\AxisLen);
                                % ] (binaryposition) --++ (\AxisLen, 0, 0) arc (0:90:\AxisLen);  % More accurate. But not sure if that makes too crowded (goes right through inclination)
                            \end{scope}
                            
                            % \draw[
                            %     distancecolor,
                            %     thick,
                            %     dashed,
                            % ] (binaryposition) --++ (\AxisLen, 0, 0) -- (0, 0, \AxisLen);
                            % -- Straight line for connection. Don't think I like more than arc
                            
                            \draw[
                                distancecolor,
                                angle,
                            ] (binaryposition) --++ (\AxisLen, 0, 0) arc (0:-90+\PhiRef:\AxisLen);
                            
                            \draw[
                                <-,
                                thick,
                                distancecolor,
                            ] (binaryposition) ++ (\AxisLen, 0, 0) arc (0:-90+\PhiRef:\AxisLen);

                            \draw[
                                draw=none,
                                distancecolor,
                            ] (binaryposition) ++ ({(1+\AxisLabelPad)*\AxisLen}, 0, 0) arc (0:-90+\PhiRef:{(1+\AxisLabelPad)*\AxisLen}) node[midway, sloped] {\AzimuthalProjectionLabel};
                        \end{scope}
                    }{}
                }{}
    
    
                % -- Helper lines
    	        \ifthenelse{\equal{\SourceFrameHelperlines}{true}}{
                    \begin{scope}[
                        canvas is xy plane at z=0,
                    ]
                        \draw[helper lines] (0.0, 0.0, 0.0) circle(\AxisLen cm) {};
                    \end{scope}
                }{}
            \end{scope}


        % -- Visualization of line of ascending node
        \ifthenelse{\equal{\SignalFrameAxes}{true} \and \equal{\SignalFrame@AscNode@Show}{true}}{
            \draw[
                layer=axes,
                ->,
            % ] (binaryposition) -- (\AxisLen, 0, 0) node[anchor=north]{AscNodeLabel};
            % -- TODO: maybe move label to other place if longascnodes = 0? Then this here coincides with y'
            % -- -> better solution: elongate line that indicates ascending node
            ] (binaryposition) -- (1.25*\AxisLen, 0, 0) node[pos=1+\AxisLabelPad]{\AscNode@Label};
        }{}
        \end{scope}

        \ifthenelse{\equal{\SignalFrameAngles}{true}}{
            % -- Visualization of LongAscOmega
            \ifnum\LongAscNodes=-90 % Doing this with LongAscOmega = 0 does not work, must be due to use of \def
            \else
                \draw[angle, longasccolor] (binaryposition) -- (xprimetip) arc
                (0:\LongAscOmega:\AxisLen);
                % (0:-\LongAscOmega:\AxisLen);
                
                \draw[
                    layer=angles,
                    ->,
                    thick,
                    longasccolor,
                ] (binaryposition) ++(xprimetip) arc (0:\LongAscOmega:\AxisLen);
                % ] (binaryposition) ++(xprimetip) arc (0:-\LongAscOmega:\AxisLen);
                
                \draw[
                    layer=angles,
                    draw=none,
                    longasccolor,
                ] (binaryposition) ++(${(1+\AxisLabelPad)}*(xprimetip)$) arc (0:\LongAscOmega:{(1+\AxisLabelPad)*\AxisLen}) node[midway] {\Omega@Label};
                % ] (binaryposition) ++(${(1+\AxisLabelPad)}*(xprimetip)$) arc (0:-\LongAscOmega:{(1+\AxisLabelPad)*\AxisLen}) node[midway] {\Omega@Label};
            \fi
    
            % -- Visualization of polarization
            \ifthenelse{\equal{\ShowCelestialFrame}{true}}{
                \ifnum\Polarization=0
                \else
                    \draw[angle, polcolor] (binaryposition) -- (xprimetip) arc
                    (0:-\Polarization:\AxisLen); % Counter-clockwise aroud z'
                    % (0:\Polarization:\AxisLen); % Clockwise aroud z'
                    
                    \draw[
                        layer=angles,
                        <-,
                        thick,
                        polcolor,
                    ] (binaryposition) ++(xprimetip) arc (0:-\Polarization:\AxisLen); % Counter-clockwise around z'
                    % ] (binaryposition) ++(xprimetip) arc (0:\Polarization:\AxisLen); % Clockwise aroud z'

                    \draw[
                        layer=angles,
                        draw=none,
                        polcolor,
                    ] (binaryposition) ++(${(1+\AxisLabelPad)}*(xprimetip)$) arc (0:-\Polarization:{(1+\AxisLabelPad)*\AxisLen}) node[midway] {\Polarization@Label}; % Counter-clockwise around z'
                    % ] (binaryposition) ++(${(1+\AxisLabelPad)}*(xprimetip)$) arc (0:\Polarization:{(1+\AxisLabelPad)*\AxisLen}) node[midway] {\Polarization@Label}; % Clockwise around z'
                \fi
            }{}
        }{}
        
    \end{scope}
    \ifthenelse{\equal{\ShowCelestialFrame}{true}}{
        \end{scope}
    }{}

	\ifthenelse{\equal{\ShowCelestialFrame}{true}}{
        % -- Visualization of relation between celestial and signal frame        
        \begin{scope}[
            % layer=angles,
            distancecolor,
            thick,
        ]
            % \tikzmath{
            %     \decrasignum = \Dec/abs(\Dec) + \Ra/abs(\Ra);
            % }
            % -- To minimize code duplication due to required if clause
            % \ifnum\decra>0
            % \ifdim\decrasignum pt>0 pt
            \ifnum\Ra<0
                \ifthenelse{\equal{\LineOfSight@Show}{true}}{
                    \draw[
                        ->,
                        layer=angles,
                    ] (earthpos) -- (binaryposition) node[midway, sloped, above]{\LineOfSightLabel};
                }{}
            
                \ifthenelse{\equal{\Binary@distance@show}{true}}{
	                \draw[
	                    decorate,
	                    decoration={
	                        brace,
	                        amplitude=10pt,
	                        % mirror, -> now handled by if clause
	                    },
                        layer=angles,
	                ] (earthpos) -- (binaryposition) node[midway, sloped, below=10]{\Distance@Label};
                }{}
            \else
                \ifthenelse{\equal{\LineOfSight@Show}{true}}{
                    \draw[
                        ->,
                    ] (earthpos) -- (binaryposition) node[midway, sloped, below]{\LineOfSightLabel};
                }{}
                
                \ifthenelse{\equal{\Binary@distance@show}{true}}{
	                \draw[
	                    decorate,
	                    decoration={
	                        brace,
	                        amplitude=10pt,
	                    },
                        layer=angles,
	                ] (earthpos) -- (binaryposition) node[midway, sloped, above=10]{\Distance@Label};
                }{}
            \fi

        \end{scope}
    }{}

} 
